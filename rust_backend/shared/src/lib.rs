//! Shared types for the trading system
//! 
//! This crate contains data structures used by all services

use serde::{Deserialize, Serialize};
use chrono::{DateTime, Utc};
use serde_json;
use uuid::Uuid;
use anyhow;

// single market data point from an exchange
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MarketTick {
    pub id: Uuid,
    pub symbol: String,
    pub price: f64,
    pub volume: u64,
    pub timestamp: DateTime<Utc>,
    pub exchange: String,
}

impl MarketTick {
    pub fn new(symbol: String, price: f64, volume: u64, exchange: String) -> Self {
        Self {
            id: Uuid::new_v4(),
            symbol,
            price,
            volume,
            timestamp: Utc::now(),
            exchange,
        }
    }
}

/// Actions the AI can decide to take
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum Action {
    Buy,
    Sell,
    Hold,
}

// signal generated by ML models
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TradingSignal {
    pub id: Uuid,
    pub symbol: String,
    pub action: Action,
    pub confidence: f64,
    pub target_price: Option<f64>,
    pub stop_loss: Option<f64>,
    pub timestamp: DateTime<Utc>,
    pub reasoning: String,
}

impl TradingSignal {
    // create new trading signal
    pub fn new(
        symbol: String,
        action: Action,
        confidence: f64,
        reasoning: String,
    ) -> Self {
        Self {
            id: Uuid::new_v4(),
            symbol,
            action,
            confidence,
            target_price: None,
            stop_loss: None,
            timestamp: Utc::now(),
            reasoning,
        }
    }

    // Set target price (builder pattern)
    pub fn with_target_price(mut self, price: f64) -> Self {
        self.target_price = Some(price);
        self
    }

    // Set stop loss (builder pattern)
    pub fn with_stop_loss(mut self, price: f64) -> Self {
        self.stop_loss = Some(price);
        self
    }
}

// let signal = TradingSignal::new("AAPL".to_string(), Action::Buy, 0.85, "Strong momentum".to_string())
// .with_target_price(150.0)
// .with_stop_loss(140.0);

// which side of the trade
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OrderSide {
    Buy,
    Sell,
}

// type of order to place
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OrderType {
    Market, // buy/sell imediately at current price
    Limit, // buy/sel only at specific price or better
    StopLoss, // sell if price drops below threshold
}

// current status of an order
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum OrderStatus {
    Pending,
    Filled,
    Cancelled,
    Rejected,
}

/// Order to be sent to a broker
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Order {
    pub id: Uuid,
    pub symbol: String,
    pub side: OrderSide,
    pub quantity: u32,
    pub order_type: OrderType,
    pub price: Option<f64>,
    pub status: OrderStatus,
    pub created_at: DateTime<Utc>,
    pub filled_at: Option<DateTime<Utc>>,
}


// Create order
impl Order {
    // create a new market order
    pub fn market_order(symbol: String, side: OrderSide, quantity: u32) -> Self {
        Self {
            id: Uuid::new_v4(),
            symbol,
            side,
            quantity,
            order_type: OrderType::Market,
            price: None,
            status: OrderStatus::Pending,
            created_at: Utc::now(),
            filled_at: None,
        }
    }

    // Create a new limit order
    pub fn limit_order(symbol: String, side: OrderSide, quantity: u32, price: f64) -> Self {
        Self {
            id: Uuid::new_v4(),
            symbol,
            side,
            quantity,
            order_type: OrderType::Limit,
            price: Some(price),
            status: OrderStatus::Pending,
            created_at: Utc::now(),
            filled_at: None,
        }
    }

    // Mark order as filled
    pub fn mark_filled(&mut self) {
        self.status = OrderStatus::Filled;
        self.filled_at = Some(Utc::now());
    }
}

// configuration for all the services
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Config {
    pub database_url: String,
    pub redis_url: String,
    pub polygon_api_key: String,
    pub finnhub_api_key: String,
    pub quiver_api_key: String,
    pub alpaca_api_key: String,
}

impl Config {
    /// Load configuration from environment variables
    pub fn from_env() -> anyhow::Result<Self> {
        let database_url = std::env::var("DATABASE_URL")
            .unwrap_or_else(|_| "postgresql://localhost/trading_db".to_string());
        
        let redis_url = std::env::var("REDIS_URL")
            .unwrap_or_else(|_| "redis://localhost".to_string());
            
        let polygon_api_key = std::env::var("POLYGON_API_KEY")
            .unwrap_or_else(|_| "not_set".to_string());
        
        let finnhub_api_key = std::env::var("FINNHUB_API_KEY")
            .map_err(|_| anyhow::anyhow!("FINNHUB_API_KEY environment variable not set"))?;
        
        let quiver_api_key = std::env::var("QUIVER_API_KEY")
            .unwrap_or_else(|_| "not_set".to_string());
            
        let alpaca_api_key = std::env::var("ALPACA_API_KEY")
            .unwrap_or_else(|_| "not_set".to_string());
        
        Ok(Config {
            database_url,
            redis_url,
            polygon_api_key,
            finnhub_api_key,
            quiver_api_key,
            alpaca_api_key,
        })
    }
}

// alternative data event types
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum AltDataType {
    CongressionalTrade,
    GovernmentContract,
    NewsSentiment,
}

// normalized alternative data event used across services
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AltDataEvent {
    pub id: Uuid,
    pub event_type: AltDataType,
    pub symbol: Option<String>,
    pub description: String,
    pub impact_score: f64,
    pub timestamp: DateTime<Utc>,
    pub metadata: serde_json::Value,
}
